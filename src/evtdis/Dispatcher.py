"""
Copyright(c) 2025-present, MathTix, LLC.
Distributed under the MIT License (http://opensource.org/licenses/MIT)
"""

import logging
from inspect import ismethod
from inspect import signature
from inspect import Signature
from queue import Queue
from queue import Empty
from threading import Thread
from typing import Optional
from typing import Tuple
from typing import Union
from .Event import Event
from .Event import EventType
from .Event import ParameterDict
from .Publisher import EventCallback
from .Publisher import Publisher

# Setup logging
_LOGGER = logging.getLogger(__name__)


class Dispatcher(Thread):
    """
    The dispatcher class provides a thread safe mechanism for receiving events and
    dispatching and processing the events on a single thread. This frees the event
    sender to do other processing and allows the receiver to process events in order
    on the same thread with no need to lock local data structures.
    """

    class Evt():
        Running: type = EventType(name='Running')
        Idle: type = EventType(name='Idle')
        Exiting: type = EventType(name='Exiting')

    def __init__(self, name: str, qsize: int = 256) -> None:
        """
        Initialize a dispatcher with the specified name for logging and event queue size.
        :param name: A string that contains the name to appear in log entries.
        :param qsize: The size of the event queue.
        """
        Thread.__init__(self, name=name)

        self._idleTimeout: float = 0.05
        self._internalPublisher: Publisher = Publisher(name=name + ':' + 'Internal')
        self._inputPublisher: Publisher = Publisher(name=name + ':' + 'Input')
        self._outputPublisher: Publisher = Publisher(name=name + ':' + 'Output')

        self._startEventType: Optional[type] = None
        self._idleEventType: Optional[type] = None
        self._exitEventType: Optional[type] = None
        self._queue: Queue = Queue(maxsize=qsize)
        self._return: bool = True

    ####################################################################################################################
    # Private
    ####################################################################################################################

    def _log(self, msg, *args, **kwargs) -> None:
        """
        Adds instance name to the log message.
        """
        msg: str = '[{}] '.format(self._name) + msg
        _LOGGER.debug(msg, *args, **kwargs)

    def _verifyParameters(self, call: EventCallback, params: dict) -> None:
        """
        Verify the call object parameters match the vales in the dictionary.
        :param call: A method object whose parameters will be matched agains the input dictionary.
        :param params: A dictionary object which contains parameter name type entries.
        :return: A boolean value which indicates it the parameters match.
        """
        if not ismethod(call):
            raise TypeError('Call object [{}] is not a method'.format(call))

        sigkeys: Signature = signature(call).parameters.keys()
        if len(sigkeys) != len(params):
            raise TypeError('Parameter list mismatch [{}] != [{}]'.format(sigkeys, params.keys()))

        for par in sigkeys:
            if par not in params:
                raise TypeError('Parameter name mismatch %s not in parameter dictionary')

    ####################################################################################################################
    # Public Properties
    ####################################################################################################################

    @property
    def idleTimeout(self) -> float:
        """
        Retrieves the maximum amount of time the event loop sleeps on the event queue before processing the idle
        event if set.
        :return: A floating point value which is the number of seconds between idle event processing.
        """
        return self._idleTimeout

    @idleTimeout.setter
    def idleTimeout(self, timeout: float) -> None:
        """
        Sets the maximum time interval between idle event processing calls.
        :param timeout: A floating point value which specifies the maximum number of seconds between idle event process
        """
        self._idleTimeout = timeout

    @property
    def startEventType(self) -> type:
        """
        Retrieves the event type that current generated by dispatcher when the event loop starts.
        :return: A subclass of type that identifies the event which signals an the start of the event loop.
        """
        return self._startEventType

    @startEventType.setter
    def startEventType(self, eventType: type) -> None:
        """
        Set a new value for the start event type.
        :param eventType: A subclass of type that identifies the event which signals the start of event processing.
        """
        self._startEventType = eventType

    @property
    def idleEventType(self) -> type:
        """
        Retrieves the event type that current generated by dispatcher when the is idle.
        :return: A subclass of type that identifies the event which signals an idle event loop.
        """
        return self._idleEventType

    @idleEventType.setter
    def idleEventType(self, eventType: type) -> None:
        """
        Set a new value for the idle event type.
        :param eventType: A subclass of type that identifies the event which signals an idle event loop.
        """
        self._idleEventType = eventType

    @property
    def exitEventType(self) -> type:
        """
        Retrieves the event type that current signals the dispatcher to exit event processing.
        :return: A subclass of type that identifies the event which signals an exit.
        """
        return self._exitEventType

    @exitEventType.setter
    def exitEventType(self, eventType: type) -> None:
        """
        Set a new value for the exit event type.
        :param eventType: A subclass of type that identifies the event which signals an exit.
        """
        self._exitEventType = eventType

    ####################################################################################################################
    # Protected - Internal event processing
    ####################################################################################################################

    # Query for supported events.
    def _internalEventTypes(self) -> Tuple[type, ...]:
        """
        Retrieve the types of nexternal events to which the event thread responds.
        :return: A tuple of event types to which the event thread responds.
        """
        return self._internalPublisher.eventTypes

    def _subscribeInternalEvent(self, eventType: type, call: Optional[EventCallback]=None) -> None:
        """
        Add the event type represented by the eventType parameter to invoke the instance method represented by
        the call parameter for an event coming through the event loop.
        :param eventType: A subclass of type that identifies the event to be subscribed.
        :param call: A callable object that is to be subscribed to the specified event type.
        """
        if call is not None:
            params: ParameterDict = eventType.getParameters()
            self._verifyParameters(call=call, params=params)
        self._internalPublisher.registerEvent(eventType=eventType)
        if call is not None:
            self._internalPublisher.subscribe(eventType=eventType, call=call)

    def _unsubscribeInternalEvent(self, eventType: type, call: Optional[EventCallback]=None) -> None:
        """
        Unsubscribe the specified call from the event type represented by the eventType parameter.
        :param eventType: A subclass of type that identifies the event from which to be unsubscribed.
        :param call: A callable object that is to be unsubscribed from the specified event type.
        """
        self._internalPublisher.unsubscribe(eventType=eventType, call=call)

    def _subscribeInputEvent(self, eventType: type, call: EventCallback) -> None:
        """
        Add the input event type represented by the eventType parameter to invoke the instance method represented by
        the call parameter to process events of the specified type.
        :param eventType: A subclass of type that identifies the event type to be added.
        :param call: A callable object that is to be subscribed to the specified event.
        """
        params: ParameterDict = eventType.getParameters()
        self._verifyParameters(call=call, params=params)
        # Add the command as an externally visible command.
        self._inputPublisher.registerEvent(eventType=eventType)
        # Subscribe the event loop to this input event.
        self._inputPublisher.subscribe(eventType=eventType, call=self._publishInternalEvent)
        # Add processing coming out of the event loop.
        self._subscribeInternalEvent(eventType=eventType, call=call)

    def _registerOutputEvent(self, eventType: type) -> None:
        """
        Register an output event type which is available for subscription.
        :param eventType: A subclass of type that identifies the event type to be added.
        """
        self._outputPublisher.registerEvent(eventType=eventType)

    def _publishInternalEvent(self, event: Event) -> None:
        """
        Publish the specified event through the event queue which will then be dispatched to all
        internal subscribers.
        :param event: A subclass of Event that will be published to all internal subscribers.
        """
        self._queue.put(item=event, block=True)

    def _publishExternalEvent(self, event: Event) -> None:
        """
        Publish the specified event through the output publisher which will be dipatched to all
        external subscribers.
        :param event: A subclass of Event that will be published to all external subscribers.
        """
        self._outputPublisher.publish(event=event)

    ####################################################################################################################
    # Public
    ####################################################################################################################

    def setDefaultStartAndExit(self, startCall: Optional[EventCallback]=None,
                               exitCall: Optional[EventCallback]=None) -> None:
        """
        Convenience function to setup default start and exit processing.
        :param startCall: A subclass method to be called when the message starts running.
        :param exitCall: A subclass method to be called when the message loop exits.
        """
        if not ismethod(startCall) and not ismethod(exitCall):
            raise TypeError('startCall and exitCall arguments must be callable')

        self._startEventType = Dispatcher.Evt.Running
        self._exitEventType = Dispatcher.Evt.Exiting

        if startCall is not None:
            self._subscribeInternalEvent(eventType=Dispatcher.Evt.Running, call=startCall)
        if exitCall is not None:
            self._subscribeInternalEvent(eventType=Dispatcher.Evt.Exiting, call=exitCall)

    # Query for supported events.
    def inputEventTypes(self) -> tuple:
        """
        Retrieve the external event types to which the event thread responds.
        :return: A tuple of event types to which the event thread responds.
        """
        return self._inputPublisher.eventTypes

    def outputEventTypess(self) -> tuple:
        """
        Retrieve the external output event types to which clients may subscribe.
        :return: A tuple of output event types to which clients may subscribe.
        """
        return self._outputPublisher.eventTypes

    # Event processing
    def deliverInputEvent(self, event: Event) -> None:
        """
        Deliver an input event to the event loop for internal processing
        :param event: An instance of the event to be delivered.
        """
        self._inputPublisher.publish(event=event)

    # subscription management.
    def subscribeToOutputEvent(self, eventType: type, call: EventCallback) -> None:
        """
        Subscribe the input call object to the specified event type.
        :param eventType: A subclass of type which specifies the event type for which the call will be invoked.
        :param call: A callable object to which the events of the specified type will be delivered.
        """
        self._outputPublisher.subscribe(eventType=eventType, call=call)

    def unsubscribeFromOutputEvent(self, eventType: type, call: EventCallback) -> None:
        """
        Unsubscribe the input call object from the specified event type.
        :param eventType: A subclass of type which specifies the event type for which the call will be unsubscribed.
        :param call: A callable object which will be unsubscribed.
        """
        self._outputPublisher.unsubscribe(eventType=eventType, call=call)

    def subscribeToRemoteOutputEvent(self, eventType: type,
                                     source: Union[Publisher, Thread], call: EventCallback) -> None:
        """
        Subscribe the specified event generated by the source object to invoke the call.
        :param eventType: A subclass of type which is the event for which call will be invoked remotely.
        :param source: A dispatcher instance on which to subscribe for the event.
        :param call: A callable object which will be subscribed.
        """
        if issubclass(type(source), Publisher):
            source.subscribe(eventType=eventType, call=self._publishInternalEvent)
        elif issubclass(type(source), Dispatcher):
            source.subscribeToOutputEvent(eventType=eventType, call=self._publishInternalEvent)
        else:
            raise TypeError('[{}] is not a Publisher or Dispatcher'.format(type(source)))
        self._subscribeInternalEvent(eventType=eventType, call=call)

    def unsubscribeFromRemoteOutputEvent(self, eventType: type, source, call) -> None:
        """
        TO DO
        :param eventType:
        :param source:
        :param call:
        """
        pass

    def triggerExit(self, **args) -> bool:
        """
        Trigger the exit event if one is set.
        :param args: Arguments to the exit function. May be empty tuple.
        :return: A boolean value that indicates if the exit event was triggered.
        """
        if self._exitEventType:
            event = self._exitEventType(**args)
            self._publishInternalEvent(event=event)
        return self._exitEventType is not None

    ####################################################################################################################
    # Internal Event processing loop.
    ####################################################################################################################

    def run(self) -> None:
        """
        The run method overrides the run method in the Thread class and performs internal event processing. The run
        method should not be called directly. The proper way start internal event processing is to call the Thread clas
        start method. A start event if set is generating at the beginning of the run loop. An ideEvent processing loop
        continues until an exit event is received.
        """
        try:
            self._log('Starting event processing loop')
            if self._startEventType is not None and self._startEventType in self._internalPublisher.eventTypes:
                self._internalPublisher.publish(event=self._startEventType())

            doProcess: bool = True
            doTrigger: bool = True
            doBlock: bool = True

            while doProcess:
                try:
                    event: Event = self._queue.get(block=doBlock, timeout=self.idleTimeout)
                    self._log('Processing [%s] event', event.__class__)

                    # Exit event processing
                    if event.__class__ is self._exitEventType:
                        doProcess = False
                        if self._exitEventType not in self._internalPublisher.eventTypes:
                            doTrigger = False

                    if doTrigger:
                        self._internalPublisher.publish(event=event)

                except Empty:
                    # queue.Get timed out.
                    if self.idleEventType and self.idleEventType in self._internalPublisher.eventTypes:
                        # Do not block when an idle event is available.
                        doBlock = False
                        self._internalPublisher.publish(event=self._idleEventType())
                    else:
                        # Block when no idle event is available.
                        doBlock = True

            self._log('Exiting event processing loop')

        except Exception:
            _LOGGER.exception('Run loop exception', exc_info=True, stack_info=True)
            self._return = False

    def join(self, timeout=None) -> bool:
        """
        Join with return value.
        :param timeout: See Thread.join()
        :return: A boolean value that indicates whether or not processing was successful. False: error, True: no error.
        """
        super().join(timeout=timeout)
        return self._return
